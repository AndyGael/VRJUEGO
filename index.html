<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Crossy Road 3D ‚Äì Enhanced VR</title>
  <style>
    html, body { 
      margin:0; 
      height:100%; 
      background: linear-gradient(135deg, #020617 0%, #020617 100%);
      overflow:hidden; 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    
    #hud {
      position: fixed; 
      top: 16px; 
      left: 16px; 
      right: 16px;
      display:flex; 
      justify-content:space-between; 
      align-items:center;
      color:#fff; 
      z-index:10; 
      pointer-events:none;
      text-shadow: 0 3px 6px rgba(0,0,0,.8);
    }
    
    .pill{ 
      pointer-events:none; 
      background: linear-gradient(135deg, rgba(59, 130, 246, 0.5) 0%, rgba(37, 99, 235, 0.5) 100%);
      backdrop-filter: blur(10px);
      padding: 10px 16px; 
      border-radius: 20px; 
      font-weight: 700;
      font-size: 16px;
      border: 1px solid rgba(255,255,255,0.2);
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }
    
    #level-indicator {
      position: fixed;
      top: 70px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, rgba(168, 85, 247, 0.6) 0%, rgba(139, 92, 246, 0.6) 100%);
      backdrop-filter: blur(10px);
      padding: 8px 20px;
      border-radius: 20px;
      color: #fff;
      font-weight: 700;
      z-index: 10;
      border: 1px solid rgba(255,255,255,0.3);
      box-shadow: 0 4px 15px rgba(0,0,0,0.4);
    }
    
    #progress { 
      position:fixed; 
      bottom: 16px; 
      left: 16px; 
      right: 16px; 
      height: 10px; 
      background: rgba(0,0,0,0.4);
      backdrop-filter: blur(5px);
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.1);
      overflow: hidden;
    }
    
    #bar { 
      height:100%; 
      width:0%; 
      background: linear-gradient(90deg, #4ade80 0%, #22c55e 100%);
      border-radius: 10px; 
      transition: width .3s ease;
      box-shadow: 0 0 20px rgba(74, 222, 128, 0.6);
    }
    
    #loading-text {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 24px;
      font-weight: 700;
      z-index: 25;
      text-align: center;
    }
    
    #gameover, #start-screen {
      position:fixed; 
      inset:0; 
      display:none; 
      place-items:center; 
      background: rgba(0,0,0,.85);
      backdrop-filter: blur(10px);
      color:#fff; 
      text-align:center; 
      z-index:20;
      animation: fadeIn 0.3s ease;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    #card, #start-card { 
      background: linear-gradient(135deg, #020617 0%, #020617 100%);
      padding: 32px; 
      border-radius: 24px; 
      box-shadow: 0 20px 60px rgba(0,0,0,.9);
      max-width: 480px;
      border: 1px solid rgba(255,255,255,0.1);
      animation: slideUp 0.4s ease;
    }
    
    @keyframes slideUp {
      from { transform: translateY(30px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    
    #card h1, #start-card h1 { 
      margin:0 0 12px 0; 
      font-size: 36px;
      background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    #card p, #start-card p { 
      opacity:.9; 
      font-size: 18px;
      margin: 8px 0;
    }
    
    #card button, #start-card button { 
      margin-top: 16px; 
      background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
      color: #fff; 
      border: 0; 
      padding: 14px 28px; 
      border-radius: 12px; 
      font-weight: 700;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(34, 197, 94, 0.4);
    }
    
    #card button:hover, #start-card button:hover { 
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(34, 197, 94, 0.6);
    }
    
    #mobile { 
      position:fixed; 
      bottom: 80px; 
      left:50%; 
      transform:translateX(-50%); 
      display:none; 
      gap: 12px; 
      z-index:15;
    }
    
    .btn-container {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
      width: 180px;
    }
    
    .btn { 
      background: linear-gradient(135deg, rgba(59, 130, 246, 0.4) 0%, rgba(37, 99, 235, 0.4) 100%);
      backdrop-filter: blur(10px);
      color: #fff; 
      border: 1px solid rgba(255,255,255,.2); 
      padding: 16px; 
      border-radius: 12px; 
      min-width: 50px;
      text-align: center;
      font-weight: 700;
      font-size: 18px;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }
    
    .btn:active {
      transform: scale(0.95);
      background: linear-gradient(135deg, rgba(37, 99, 235, 0.6) 0%, rgba(29, 78, 216, 0.6) 100%);
    }
    
    .btn[data-k="KeyW"] { grid-column: 2; }
    .btn[data-k="KeyA"] { grid-column: 1; grid-row: 2; }
    .btn[data-k="KeyS"] { grid-column: 2; grid-row: 2; }
    .btn[data-k="KeyD"] { grid-column: 3; grid-row: 2; }
    
    .stats {
      display: flex;
      justify-content: space-around;
      margin: 20px 0;
      gap: 16px;
    }
    
    .stat-item {
      flex: 1;
      background: rgba(255,255,255,0.05);
      padding: 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .stat-label {
      font-size: 14px;
      opacity: 0.7;
      margin-bottom: 4px;
    }
    
    .stat-value {
      font-size: 24px;
      font-weight: 700;
      color: #4ade80;
    }
    
    @media (max-width: 820px){
      #mobile { display:block; }
      #progress { bottom: 160px; }
    }
  </style>
</head>
<body>
  <!-- Loading Screen -->
  <div id="loading-text">Cargando modelos 3D...<br><span style="font-size:16px;" id="percent">0%</span></div>
  
  <!-- Start Screen -->
  <div id="start-screen">
    <div id="start-card">
      <h1>üéÆ Crossy Road 3D VR</h1>
      <p>Cruza la carretera esquivando obst√°culos ‚Äì ahora en VR (Meta Quest)</p>
      <div style="margin: 20px 0; text-align: left; opacity: 0.8;">
        <p><strong>Controles teclado (PC):</strong></p>
        <p>‚Ä¢ W/‚Üë - Avanzar</p>
        <p>‚Ä¢ A/‚Üê - Izquierda</p>
        <p>‚Ä¢ S/‚Üì - Retroceder</p>
        <p>‚Ä¢ D/‚Üí - Derecha</p>
        <p style="margin-top:12px;"><strong>Controles VR (Quest):</strong></p>
        <p>‚Ä¢ Joystick ‚Äì mover por la cuadr√≠cula</p>
        <p>‚Ä¢ Gira la cabeza ‚Äì c√°mara en primera persona</p>
      </div>
      <button id="start-btn">¬°Comenzar!</button>
    </div>
  </div>

  <!-- HUD -->
  <div id="hud" style="display:none;">
    <div class="pill">üìç Distancia: <span id="dist">0</span></div>
    <div class="pill">‚ù§Ô∏è Vidas: <span id="lives">3</span></div>
    <div class="pill">‚≠ê Puntos: <span id="score">0</span></div>
  </div>
  
  <div id="level-indicator" style="display:none;">Nivel <span id="level">1</span></div>
  
  <div id="progress"><div id="bar"></div></div>
  
  <!-- Game Over Screen -->
  <div id="gameover">
    <div id="card">
      <h1>¬°Juego Terminado!</h1>
      <div class="stats">
        <div class="stat-item">
          <div class="stat-label">Distancia</div>
          <div class="stat-value" id="finalDist">0</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">Puntos</div>
          <div class="stat-value" id="finalScore">0</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">Nivel</div>
          <div class="stat-value" id="finalLevel">1</div>
        </div>
      </div>
      <button id="retry">üîÑ Reintentar</button>
    </div>
  </div>
  
  <!-- Mobile Controls -->
  <div id="mobile">
    <div class="btn-container">
      <div class="btn" data-k="KeyW">‚Üë</div>
      <div class="btn" data-k="KeyA">‚Üê</div>
      <div class="btn" data-k="KeyS">‚Üì</div>
      <div class="btn" data-k="KeyD">‚Üí</div>
    </div>
  </div>

  <!-- Three.js + loaders -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>

  <script>
  // ============ CONFIGURATION ============
  const CONFIG = {
    tile: 2.0,
    segmentLength: 10,
    segmentsAhead: 12, // Reducido para mejor rendimiento
    segmentsBehind: 6,
    lanes: 5,
    laneWidth: 2.0,
    player: {
      speed: 0.22,
      radius: 0.8
    },
    obstacles: {
      carSpeedMin: 2.0,
      carSpeedMax: 4.5,
      logSpeedMin: 1.5,
      logSpeedMax: 3.0,
      spawnProb: 0.6
    },
    lives: 3,
    levelThreshold: 15,
    pointsPerMove: 10,
    pointsPerLevel: 100
  };

  // ============ GAME STATE ============
  let scene, camera, renderer, clock, mixer;
  let player, playerModel, isMoving = false, moveStart = 0;
  let moveFrom = new THREE.Vector3(), moveTo = new THREE.Vector3();
  let distance = 0, lives = CONFIG.lives, score = 0, level = 1;
  let segments = [];
  let obstacles = [];
  let gameStarted = false;
  let difficultyMultiplier = 1.0;
  let animations = {};
  let currentAction = null;
  
  // Loaded models
  let carModels = [];
  let modelsToLoad = 0;
  let modelsLoaded = 0;

  // ============ VR / AUDIO / NAVIGATION STATE ============
  let vrRig = null;
  let controller1 = null;
  let controller2 = null;
  let controllerGamepad1 = null;
  let controllerGamepad2 = null;
  let lastVRMoveTime = 0;
  const VR_MOVE_COOLDOWN = 200; // ms entre movimientos de rejilla

  // Audio
  let audioListener = null;
  let bgMusic = null;
  let collisionSound = null;
  let audioLoader = null;

  // L√≠mites de navegaci√≥n (X/Z) seg√∫n segmentos generados
  const navBounds = {
    minX: null,
    maxX: null,
    minZ: null,
    maxZ: null
  };

  // Texturas terreno (solo TEXTURAS/)
  const textureLoader = new THREE.TextureLoader();

  // ============ UI ELEMENTS ============
  const distUI = document.getElementById('dist');
  const livesUI = document.getElementById('lives');
  const scoreUI = document.getElementById('score');
  const levelUI = document.getElementById('level');
  const bar = document.getElementById('bar');
  const gameover = document.getElementById('gameover');
  const startScreen = document.getElementById('start-screen');
  const loadingText = document.getElementById('loading-text');
  const percentText = document.getElementById('percent');
  const hud = document.getElementById('hud');
  const levelIndicator = document.getElementById('level-indicator');
  const finalDist = document.getElementById('finalDist');
  const finalScore = document.getElementById('finalScore');
  const finalLevel = document.getElementById('finalLevel');
  const retryBtn = document.getElementById('retry');
  const startBtn = document.getElementById('start-btn');

  // ============ MATERIALS (global) ============
  let materials = {};

  // ============ MINIMAL VR BUTTON (WebXR entry) ============
  const VRButton = {
    createButton: function (renderer, options) {
      if (!options) options = {};
      const button = document.createElement('button');
      button.style.position = 'absolute';
      button.style.bottom = '20px';
      button.style.right = '20px';
      button.style.padding = '12px 18px';
      button.style.borderRadius = '999px';
      button.style.border = 'none';
      button.style.fontSize = '14px';
      button.style.fontWeight = '600';
      button.style.cursor = 'pointer';
      button.style.background = '#22c55e';
      button.style.color = '#020617';
      button.style.boxShadow = '0 0 18px rgba(0,0,0,0.45)';
      button.textContent = 'Enter VR';

      function showEnterVR() {
        button.textContent = 'Enter VR';
      }

      function showExitVR() {
        button.textContent = 'Exit VR';
      }

      function showUnsupported() {
        button.textContent = 'VR no disponible';
        button.disabled = true;
        button.style.background = '#4b5563';
      }

      function showError(error) {
        console.error(error);
        button.textContent = 'Error VR';
        button.disabled = true;
        button.style.background = '#dc2626';
      }

      if (!('xr' in navigator)) {
        showUnsupported();
        return button;
      }

      navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
        if (!supported) {
          showUnsupported();
          return;
        }

        let currentSession = null;

        async function onSessionStarted(session) {
          currentSession = session;
          await renderer.xr.setSession(session);
          button.textContent = 'Exit VR';
          
          session.addEventListener('end', onSessionEnded);
          
          // Configuraci√≥n para Meta Quest
          if (session.updateRenderState) {
            session.updateRenderState({
              baseLayer: new XRWebGLLayer(session, renderer.getContext())
            });
          }
        }

        function onSessionEnded() {
          currentSession = null;
          button.textContent = 'Enter VR';
        }

        button.addEventListener('click', async function () {
          if (currentSession === null) {
            try {
              const sessionInit = { 
                optionalFeatures: ['local-floor', 'bounded-floor']
              };
              const session = await navigator.xr.requestSession('immersive-vr', sessionInit);
              await onSessionStarted(session);
            } catch (err) {
              console.error('Error al iniciar sesi√≥n VR:', err);
              showError(err);
            }
          } else {
            await currentSession.end();
          }
        });
      }).catch(showError);

      return button;
    }
  };

  // ============ VERIFICACI√ìN DE VR ============
  function checkVRSupport() {
    if ('xr' in navigator) {
      return navigator.xr.isSessionSupported('immersive-vr');
    }
    return Promise.resolve(false);
  }

  // ============ VR CONTROLLERS & JOYSTICK INPUT ============
  function setupVRControllers() {
    if (!renderer || !renderer.xr) return;

    controller1 = renderer.xr.getController(0);
    controller2 = renderer.xr.getController(1);

    const controllerGeom = new THREE.CapsuleGeometry(0.02, 0.08, 4, 8);
    const controllerMat = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      emissive: 0x22c55e,
      emissiveIntensity: 0.4
    });

    const controllerMesh1 = new THREE.Mesh(controllerGeom, controllerMat);
    controllerMesh1.position.set(0, 0, -0.05);
    controller1.add(controllerMesh1);

    const controllerMesh2 = new THREE.Mesh(controllerGeom, controllerMat);
    controllerMesh2.position.set(0, 0, -0.05);
    controller2.add(controllerMesh2);

    // Eventos de conexi√≥n para Meta Quest
    controller1.addEventListener('connected', function (event) {
      console.log('Controller 1 connected:', event.data);
      this.userData.gamepad = event.data.gamepad;
      controllerGamepad1 = this.userData.gamepad;
    });

    controller1.addEventListener('disconnected', function () {
      console.log('Controller 1 disconnected');
      controllerGamepad1 = null;
      delete this.userData.gamepad;
    });

    controller2.addEventListener('connected', function (event) {
      console.log('Controller 2 connected:', event.data);
      this.userData.gamepad = event.data.gamepad;
      controllerGamepad2 = this.userData.gamepad;
    });

    controller2.addEventListener('disconnected', function () {
      console.log('Controller 2 disconnected');
      controllerGamepad2 = null;
      delete this.userData.gamepad;
    });

    scene.add(controller1);
    scene.add(controller2);
  }

  // Lee el joystick y lo traduce a W/A/S/D en rejilla
  function processVRInput(dt) {
    if (!renderer || !renderer.xr || !renderer.xr.isPresenting || !player) return;
    const now = performance.now();
    if (now - lastVRMoveTime < VR_MOVE_COOLDOWN) return;

    let axisX = 0;
    let axisY = 0;
    
    // Verifica gamepads activos
    const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
    
    for (const gamepad of gamepads) {
      if (!gamepad) continue;
      
      // Meta Quest usa axes 2 y 3 para el joystick principal
      if (gamepad.axes && gamepad.axes.length >= 4) {
        const x = gamepad.axes[2] || 0;
        const y = gamepad.axes[3] || 0;
        
        if (Math.abs(x) > Math.abs(axisX)) axisX = x;
        if (Math.abs(y) > Math.abs(axisY)) axisY = y;
      }
    }

    const threshold = 0.45;
    let code = null;

    if (axisY < -threshold) {
      code = 'KeyW';
    } else if (axisY > threshold) {
      code = 'KeyS';
    } else if (axisX < -threshold) {
      code = 'KeyA';
    } else if (axisX > threshold) {
      code = 'KeyD';
    }

    if (code) {
      handleMove(code);
      lastVRMoveTime = now;
    }
  }

  // Actualiza l√≠mites de navegaci√≥n con base en segmentos activos
  function updateNavigationBounds() {
    if (!segments.length) return;
    const first = segments[0];
    const last = segments[segments.length - 1];
    const maxLane = Math.floor(CONFIG.lanes / 2) * CONFIG.laneWidth;

    navBounds.minX = -maxLane;
    navBounds.maxX = maxLane;

    navBounds.minZ = -last.z * CONFIG.tile - CONFIG.tile * 0.5;
    navBounds.maxZ = -first.z * CONFIG.tile + CONFIG.tile * 0.5;
  }

  // ============ INITIALIZATION ============
  init();

  function init() {
    console.log('Iniciando juego...');
    
    // Scene setup (tema nocturno / survival)
    scene = new THREE.Scene();
    const nightColor = new THREE.Color(0x050816);
    scene.background = nightColor.clone();
    scene.fog = new THREE.Fog(nightColor.getHex(), 20, 70);

    clock = new THREE.Clock();

    // Camera + VR rig
    camera = new THREE.PerspectiveCamera(
      55, 
      window.innerWidth / window.innerHeight, 
      0.1, 
      500
    );

    vrRig = new THREE.Group();
    vrRig.position.set(0, 0, 8);
    camera.position.set(0, 1.6, 0); // altura de ojos
    vrRig.add(camera);
    scene.add(vrRig);

    // Renderer + WebXR
    renderer = new THREE.WebGLRenderer({ 
      antialias: true,
      alpha: false 
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.6;
    renderer.outputEncoding = THREE.sRGBEncoding;
    
    // Configuraci√≥n WebXR para Meta Quest
    renderer.xr.enabled = true;
    renderer.xr.setReferenceSpaceType('local-floor'); // Importante para Quest
    
    document.body.appendChild(renderer.domElement);

    const vrButton = VRButton.createButton(renderer);
    document.body.appendChild(vrButton);

    // Verifica soporte VR
    checkVRSupport().then((supported) => {
      if (supported) {
        console.log('VR is supported on this device');
      } else {
        console.warn('VR is not supported on this device');
      }
    });

    // Iluminaci√≥n nocturna
    const hemi = new THREE.HemisphereLight(0x555577, 0x050509, 0.8);
    scene.add(hemi);
    
    const sun = new THREE.DirectionalLight(0xfff1c1, 1.0);
    sun.position.set(10, 20, 5);
    sun.castShadow = true;
    sun.shadow.camera.left = -30;
    sun.shadow.camera.right = 30;
    sun.shadow.camera.top = 30;
    sun.shadow.camera.bottom = -30;
    sun.shadow.mapSize.width = 1024; // Reducido para mejor rendimiento
    sun.shadow.mapSize.height = 1024;
    scene.add(sun);

    // Texturas desde TEXTURAS/
    try {
      const grassTex = textureLoader.load('TEXTURAS/grass.png');
      grassTex.wrapS = grassTex.wrapT = THREE.RepeatWrapping;
      grassTex.anisotropy = 2;

      const roadTex = textureLoader.load('TEXTURAS/road.png');
      roadTex.wrapS = roadTex.wrapT = THREE.RepeatWrapping;
      roadTex.anisotropy = 2;

      const woodTex = textureLoader.load('TEXTURAS/wood.png');
      woodTex.wrapS = woodTex.wrapT = THREE.RepeatWrapping;
      woodTex.anisotropy = 2;

      const rockTex = textureLoader.load('TEXTURAS/rock.png');
      rockTex.wrapS = rockTex.wrapT = THREE.RepeatWrapping;
      rockTex.anisotropy = 2;

      // Materials usando SOLO las texturas
      materials.grass = new THREE.MeshStandardMaterial({ 
        map: grassTex,
        roughness: 0.9,
        metalness: 0.0
      });
      
      materials.road = new THREE.MeshStandardMaterial({ 
        map: roadTex,
        roughness: 0.85,
        metalness: 0.05
      });
      
      materials.roadLine = new THREE.MeshStandardMaterial({ 
        color: 0xfbbf24,
        emissive: 0xfbbf24,
        emissiveIntensity: 0.3,
        roughness: 0.7,
        metalness: 0.0
      });
      
      materials.log = new THREE.MeshStandardMaterial({ 
        map: woodTex,
        roughness: 0.8,
        metalness: 0.1
      });
      
      materials.rock = new THREE.MeshStandardMaterial({ 
        map: rockTex,
        roughness: 1.0,
        metalness: 0
      });
    } catch (error) {
      console.error('Error configurando texturas:', error);
      // Usar materiales b√°sicos si hay error
      materials.grass = new THREE.MeshStandardMaterial({ color: 0x2d5a27 });
      materials.road = new THREE.MeshStandardMaterial({ color: 0x333333 });
      materials.roadLine = new THREE.MeshStandardMaterial({ color: 0xfbbf24, emissive: 0xfbbf24, emissiveIntensity: 0.3 });
      materials.log = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
      materials.rock = new THREE.MeshStandardMaterial({ color: 0x666666 });
    }

    // Audio - cargar solo si existen
    audioListener = new THREE.AudioListener();
    camera.add(audioListener);
    audioLoader = new THREE.AudioLoader();
    bgMusic = new THREE.Audio(audioListener);
    collisionSound = new THREE.Audio(audioListener);

    // Ground container
    window.ground = new THREE.Group();
    scene.add(window.ground);

    // VR controllers
    setupVRControllers();

    // Cargar texturas primero (15% del progreso)
    updateLoadingProgress(15);
    
    // Load models
    setTimeout(() => {
      loadModels();
    }, 100);

    // Event listeners
    window.addEventListener('resize', onResize);
    window.addEventListener('keydown', onKey);
    
    // Mobile controls
    document.querySelectorAll('#mobile .btn').forEach(b => {
      b.addEventListener('click', () => {
        if (!gameStarted) return;
        handleMove(b.getAttribute('data-k'));
      });
    });

    // Start button
    startBtn.onclick = startGame;
    retryBtn.onclick = () => location.reload();

    console.log('Inicializaci√≥n completada, cargando modelos...');
  }

  // ============ MODEL LOADING (CORREGIDO) ============
  function loadModels() {
    const gltfLoader = new THREE.GLTFLoader();
    const fbxLoader = new THREE.FBXLoader();

    // Contar cu√°ntos modelos necesitamos cargar
    modelsToLoad = 0;
    modelsLoaded = 0;
    
    // Autos que intentaremos cargar
    const carFiles = ['Models/car1.glb', 'Models/car2.glb', 'Models/coupe_car.glb'];
    modelsToLoad += carFiles.length;
    modelsToLoad += 1; // Player model
    
    console.log(`Total de modelos a cargar: ${modelsToLoad}`);

    // Funci√≥n para actualizar progreso
    function updateModelProgress() {
      modelsLoaded++;
      const progress = 15 + (modelsLoaded / modelsToLoad) * 80; // 15-95%
      updateLoadingProgress(progress);
      console.log(`Modelo ${modelsLoaded}/${modelsToLoad} cargado (${Math.round(progress)}%)`);
      
      if (modelsLoaded >= modelsToLoad) {
        console.log('‚úÖ Todos los modelos cargados');
        setTimeout(finishLoading, 500);
      }
    }

    // Cargar modelos de autos
    carFiles.forEach((carPath) => {
      gltfLoader.load(
        carPath,
        (gltf) => {
          try {
            const model = gltf.scene;
            
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const targetSize = 2.0;
            const normalizeScale = targetSize / maxDim;
            
            model.scale.set(normalizeScale, normalizeScale, normalizeScale);
            
            box.setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            model.position.set(-center.x, 0, -center.z);
            
            const wrapper = new THREE.Group();
            wrapper.add(model);
            
            wrapper.traverse((child) => {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
              }
            });
            
            carModels.push(wrapper);
            console.log(`‚úÖ Cargado: ${carPath}`);
          } catch (error) {
            console.error(`Error procesando ${carPath}:`, error);
            const fallbackCar = createFallbackCar();
            carModels.push(fallbackCar);
          }
          updateModelProgress();
        },
        undefined,
        (error) => {
          console.error(`‚ùå Error cargando ${carPath}:`, error);
          const fallbackCar = createFallbackCar();
          carModels.push(fallbackCar);
          updateModelProgress();
        }
      );
    });

    // Cargar modelo del jugador
    setTimeout(() => {
      console.log('Cargando modelo del jugador...');
      fbxLoader.load(
        'Models/Taunt.fbx',
        (fbx) => {
          try {
            playerModel = fbx;
            playerModel.scale.set(0.01, 0.01, 0.01);
            playerModel.position.set(0, 0, 0);
            
            playerModel.traverse((child) => {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
              }
            });

            mixer = new THREE.AnimationMixer(playerModel);
            
            console.log('‚úÖ Modelo del jugador cargado');
            
            // Crear animaciones b√°sicas
            animations.idle = mixer.clipAction(new THREE.AnimationClip('idle', 1, []));
            animations.run = mixer.clipAction(new THREE.AnimationClip('run', 1, []));
            animations.death = mixer.clipAction(new THREE.AnimationClip('death', 1, []));
            
            currentAction = animations.idle;
            currentAction.play();
            
          } catch (error) {
            console.error('Error procesando modelo del jugador:', error);
            createFallbackPlayer();
          }
          updateModelProgress();
        },
        undefined,
        (error) => {
          console.error('‚ùå Error cargando modelo del jugador:', error);
          createFallbackPlayer();
          updateModelProgress();
        }
      );
    }, 500);
  }

  function createFallbackCar() {
    console.log('Creando auto de respaldo...');
    const group = new THREE.Group();
    const bodyGeo = new THREE.BoxGeometry(1.4, 0.9, 2.2);
    const bodyMat = new THREE.MeshStandardMaterial({ 
      color: Math.random() * 0xffffff,
      roughness: 0.3,
      metalness: 0.7
    });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 0.45;
    body.castShadow = true;
    group.add(body);

    const roofGeo = new THREE.BoxGeometry(1.2, 0.6, 1.2);
    const roof = new THREE.Mesh(roofGeo, bodyMat);
    roof.position.set(0, 0.9, -0.2);
    roof.castShadow = true;
    group.add(roof);

    return group;
  }

  function createFallbackPlayer() {
    console.log('Creando jugador de respaldo...');
    const geometry = new THREE.CapsuleGeometry(0.4, 1.2, 4, 8);
    const material = new THREE.MeshStandardMaterial({ 
      color: 0x22c55e,
      emissive: 0x22c55e,
      emissiveIntensity: 0.2
    });
    playerModel = new THREE.Mesh(geometry, material);
    playerModel.castShadow = true;
    playerModel.receiveShadow = true;
    mixer = new THREE.AnimationMixer(playerModel);
    
    // Crear animaciones b√°sicas
    animations.idle = mixer.clipAction(new THREE.AnimationClip('idle', 1, []));
    animations.run = mixer.clipAction(new THREE.AnimationClip('run', 1, []));
    animations.death = mixer.clipAction(new THREE.AnimationClip('death', 1, []));
    
    currentAction = animations.idle;
    currentAction.play();
  }

  function updateLoadingProgress(percent) {
    percent = Math.min(100, Math.max(0, percent));
    percentText.textContent = `${Math.round(percent)}%`;
    bar.style.width = percent + '%';
  }

  function finishLoading() {
    console.log('Finalizando carga...');
    
    // Asegurarse de que tenemos al menos un auto
    if (carModels.length === 0) {
      carModels.push(createFallbackCar());
    }
    
    // Asegurarse de que tenemos un jugador
    if (!playerModel) {
      createFallbackPlayer();
    }
    
    // Crear objeto jugador
    player = new THREE.Group();
    if (playerModel) {
      player.add(playerModel);
    }
    player.position.set(0, 0, 0);
    scene.add(player);
    
    // Actualizar progreso al 100%
    updateLoadingProgress(100);
    
    setTimeout(() => {
      loadingText.style.display = 'none';
      bar.style.display = 'none';
      startScreen.style.display = 'grid';
      console.log('‚úÖ Juego listo para comenzar');
    }, 1000);
  }

  // ============ GAME START ============
  function startGame() {
    console.log('üöÄ Iniciando juego...');
    startScreen.style.display = 'none';
    hud.style.display = 'flex';
    levelIndicator.style.display = 'block';
    gameStarted = true;
    
    // Generar segmentos iniciales
    for (let i = -CONFIG.segmentsBehind; i <= CONFIG.segmentsAhead; i++) {
      const seg = (i <= 2) ? addSafeSegment(i) : 
                   (Math.random() < 0.6 ? addRoadSegment(i) : addSafeSegment(i));
      segments.push(seg);
    }

    updateNavigationBounds();

    // Reproducir m√∫sica si est√° cargada
    if (bgMusic && bgMusic.buffer && !bgMusic.isPlaying) {
      try {
        bgMusic.play();
      } catch (error) {
        console.warn('No se pudo reproducir m√∫sica:', error);
      }
    }
    
    animate();
    console.log('üéÆ Juego en ejecuci√≥n');
  }

  // ============ SEGMENT GENERATION ============
  function addSafeSegment(zIndex) {
    const tileW = CONFIG.lanes * CONFIG.laneWidth + 4.0;
    const plane = new THREE.Mesh(
      new THREE.BoxGeometry(tileW, 0.3, CONFIG.tile), 
      materials.grass
    );
    plane.position.set(0, -0.15, -zIndex * CONFIG.tile);
    plane.receiveShadow = true;
    window.ground.add(plane);

    const created = [plane];
    
    if (Math.random() < 0.3) {
      for (let i = 0; i < 2; i++) {
        const r = new THREE.Mesh(
          new THREE.SphereGeometry(0.3 + Math.random() * 0.2),
          materials.rock
        );
        const lane = (Math.random() - 0.5) * (CONFIG.lanes - 1) * CONFIG.laneWidth;
        r.position.set(lane, 0.3, -zIndex * CONFIG.tile + (Math.random() - 0.5));
        r.castShadow = true;
        
        r.userData = {
          type: 'rock',
          isObstacle: true
        };
        
        obstacles.push(r);
        window.ground.add(r);
        created.push(r);
      }
    }

    return { z: zIndex, type: 'safe', meshes: created };
  }

  function addRoadSegment(zIndex) {
    const tileW = CONFIG.lanes * CONFIG.laneWidth + 4.0;
    const plane = new THREE.Mesh(
      new THREE.BoxGeometry(tileW, 0.3, CONFIG.tile), 
      materials.road
    );
    plane.position.set(0, -0.15, -zIndex * CONFIG.tile);
    plane.receiveShadow = true;
    window.ground.add(plane);

    const created = [plane];

    // L√≠neas de carretera
    const lineGeo = new THREE.BoxGeometry(0.15, 0.05, CONFIG.tile * 0.4);
    for (let lane = -Math.floor(CONFIG.lanes / 2); lane < Math.floor(CONFIG.lanes / 2); lane++) {
      const line = new THREE.Mesh(lineGeo, materials.roadLine);
      line.position.set(
        (lane + 0.5) * CONFIG.laneWidth, 
        0.05, 
        -zIndex * CONFIG.tile
      );
      window.ground.add(line);
      created.push(line);
    }

    const direction = Math.random() < 0.5 ? 1 : -1;
    
    // Solo agregar un auto por segmento para mejor rendimiento
    if (Math.random() < CONFIG.obstacles.spawnProb * difficultyMultiplier && carModels.length > 0) {
      const carIndex = Math.floor(Math.random() * carModels.length);
      const lane = Math.floor(Math.random() * CONFIG.lanes) - Math.floor(CONFIG.lanes / 2);
      
      const carClone = carModels[carIndex].clone();
      
      carClone.position.set(
        lane * CONFIG.laneWidth,
        0,
        -zIndex * CONFIG.tile
      );

      if (direction < 0) {
        carClone.rotation.y += Math.PI;
      }

      carClone.userData = {
        type: 'car',
        speed: THREE.Math.lerp(
          CONFIG.obstacles.carSpeedMin,
          CONFIG.obstacles.carSpeedMax,
          Math.random()
        ) * difficultyMultiplier,
        dir: direction
      };

      obstacles.push(carClone);
      window.ground.add(carClone);
      created.push(carClone);
    }

    return { z: zIndex, type: 'road', meshes: created };
  }

  // ============ INPUT HANDLING ============
  function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function onKey(e) {
    if (!gameStarted) {
      if (e.code === 'Enter' || e.code === 'Space') {
        if (startScreen.style.display !== 'none') {
          startGame();
        }
      }
      return;
    }
    handleMove(e.code);
  }

  function handleMove(code) {
    if (isMoving || !gameStarted || !player) return;
    
    const step = CONFIG.tile;
    let nx = player.position.x;
    let nz = player.position.z;
    let moved = false;

    if (code === 'KeyW' || code === 'ArrowUp') {
      nz -= step;
      moved = true;
    } else if (code === 'KeyS' || code === 'ArrowDown') {
      nz += step;
      moved = true;
    } else if (code === 'KeyA' || code === 'ArrowLeft') {
      nx -= CONFIG.laneWidth;
      moved = true;
    } else if (code === 'KeyD' || code === 'ArrowRight') {
      nx += CONFIG.laneWidth;
      moved = true;
    }

    if (!moved) return;

    const maxLane = Math.floor(CONFIG.lanes / 2) * CONFIG.laneWidth;
    nx = Math.max(-maxLane, Math.min(maxLane, nx));

    if (navBounds.minX !== null) {
      nx = Math.max(navBounds.minX, Math.min(navBounds.maxX, nx));
    }
    if (navBounds.minZ !== null) {
      nz = Math.max(navBounds.minZ, Math.min(navBounds.maxZ, nz));
    }

    isMoving = true;
    moveStart = performance.now();
    moveFrom.copy(player.position);
    moveTo.set(nx, 0, nz);

    if (animations.run) {
      if (currentAction !== animations.run) {
        if (currentAction) currentAction.fadeOut(0.2);
        currentAction = animations.run;
        currentAction.reset().fadeIn(0.2).play();
      }
    }

    const dir = new THREE.Vector3().subVectors(moveTo, moveFrom);
    if (dir.lengthSq() > 0) {
      const targetRot = Math.atan2(dir.x, dir.z);
      const startRot = player.rotation.y;
      const rotDiff = ((targetRot - startRot + Math.PI * 3) % (Math.PI * 2)) - Math.PI;
      player.userData.rotAnim = { start: startRot, diff: rotDiff };
    }
  }

  // ============ GAME LOOP ============
  function gameLoop() {
    if (!gameStarted) {
      renderer.render(scene, camera);
      return;
    }
    
    const dt = clock.getDelta();

    if (mixer) {
      mixer.update(dt);
    }

    if (isMoving && player) {
      const elapsed = performance.now() - moveStart;
      const duration = CONFIG.player.speed * 1000;
      const t = Math.min(1, elapsed / duration);
      const ease = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;

      player.position.lerpVectors(moveFrom, moveTo, ease);
      player.position.y = Math.sin(t * Math.PI) * 0.2;

      if (player.userData.rotAnim) {
        const { start, diff } = player.userData.rotAnim;
        player.rotation.y = start + diff * ease;
      }

      if (t >= 1) {
        isMoving = false;
        player.position.y = 0;
        
        if (animations.idle) {
          if (currentAction !== animations.idle) {
            if (currentAction) currentAction.fadeOut(0.3);
            currentAction = animations.idle;
            currentAction.reset().fadeIn(0.3).play();
          }
        }

        if (moveTo.z < moveFrom.z) {
          distance += 1;
          score += CONFIG.pointsPerMove;
          distUI.textContent = distance;
          scoreUI.textContent = score;

          if (distance > 0 && distance % CONFIG.levelThreshold === 0) {
            levelUp();
          }
        }

        refreshSegments();
      }
    }

    // Mover autos
    for (const o of obstacles) {
      if (!o.userData || o.userData.type !== 'car') continue;
      
      const dir = o.userData.dir || 1;
      const speed = o.userData.speed || 2.0;
      o.position.x += dir * speed * dt;

      const maxX = (CONFIG.lanes / 2) * CONFIG.laneWidth + 5;
      if (o.position.x > maxX) {
        o.position.x = -maxX;
      }
      if (o.position.x < -maxX) {
        o.position.x = maxX;
      }
    }

    checkCollisions();

    // VR input
    processVRInput(dt);

    if (player) {
      if (renderer.xr && renderer.xr.isPresenting && vrRig) {
        const targetRigPos = new THREE.Vector3(player.position.x, 0, player.position.z);
        vrRig.position.lerp(targetRigPos, 0.15);
      } else {
        const targetCam = new THREE.Vector3(
          player.position.x,
          1.6,
          player.position.z + 0.2
        );
        camera.position.lerp(targetCam, 0.1);
        const lookAt = new THREE.Vector3(
          player.position.x,
          1.6,
          player.position.z - 1.0
        );
        camera.lookAt(lookAt);
      }
    }

    renderer.render(scene, camera);
  }

  function animate() {
    renderer.setAnimationLoop(gameLoop);
  }

  // ============ COLLISION DETECTION ============
  function checkCollisions() {
    if (!player || player.userData.invincible) return;

    const playerBox = new THREE.Box3().setFromObject(player);
    
    for (const o of obstacles) {
      if (!o.parent || !o.userData) continue;
      
      if (o.userData.type === 'car' || o.userData.isObstacle) {
        const obstacleBox = new THREE.Box3().setFromObject(o);
        if (playerBox.intersectsBox(obstacleBox)) {
          onHit();
          break;
        }
      }
    }
  }

  // ============ GAME EVENTS ============
  function onHit() {
    if (player.userData.hitCooldown && 
        performance.now() - player.userData.hitCooldown < 1500) return;
    
    player.userData.hitCooldown = performance.now();
    player.userData.invincible = true;
    
    lives--;
    livesUI.textContent = lives;

    if (collisionSound && collisionSound.buffer) {
      if (collisionSound.isPlaying) collisionSound.stop();
      try {
        collisionSound.play();
      } catch (error) {
        console.warn('No se pudo reproducir sonido de colisi√≥n:', error);
      }
    }

    if (animations.death && mixer) {
      if (currentAction) currentAction.fadeOut(0.1);
      currentAction = animations.death;
      currentAction.reset();
      currentAction.setLoop(THREE.LoopOnce);
      currentAction.clampWhenFinished = true;
      currentAction.fadeIn(0.1).play();
      
      setTimeout(() => {
        if (lives > 0 && animations.idle) {
          if (currentAction) currentAction.fadeOut(0.3);
          currentAction = animations.idle;
          currentAction.reset().fadeIn(0.3).play();
        }
      }, 1000);
    }

    if (playerModel) {
      playerModel.traverse((child) => {
        if (child.isMesh && child.material) {
          const originalMat = child.material;
          child.userData.originalMaterial = originalMat.clone();
          child.material = child.material.clone();
          child.material.color.setHex(0xff0000);
          child.material.emissive.setHex(0xff0000);
          
          setTimeout(() => {
            if (child.userData.originalMaterial) {
              child.material = child.userData.originalMaterial;
            }
          }, 300);
        }
      });
    }

    if (lives <= 0) {
      setTimeout(() => {
        endGame();
      }, 1500);
    } else {
      setTimeout(() => {
        player.position.set(0, 0, player.position.z + CONFIG.tile * 2);
        moveFrom.copy(player.position);
        moveTo.copy(player.position);
        player.userData.invincible = false;
      }, 1000);
    }
  }

  function levelUp() {
    level++;
    score += CONFIG.pointsPerLevel;
    levelUI.textContent = level;
    scoreUI.textContent = score;
    
    difficultyMultiplier = 1 + (level - 1) * 0.15;
    
    levelIndicator.style.transform = 'translateX(-50%) scale(1.3)';
    levelIndicator.style.background = 'linear-gradient(135deg, rgba(251, 191, 36, 0.8) 0%, rgba(245, 158, 11, 0.8) 100%)';
    
    setTimeout(() => {
      levelIndicator.style.transform = 'translateX(-50%) scale(1)';
      levelIndicator.style.background = 'linear-gradient(135deg, rgba(168, 85, 247, 0.6) 0%, rgba(139, 92, 246, 0.6) 100%)';
    }, 500);
  }

  function endGame() {
    gameStarted = false;
    gameover.style.display = 'grid';
    finalDist.textContent = distance;
    finalScore.textContent = score;
    finalLevel.textContent = level;
    
    if (bgMusic && bgMusic.isPlaying) {
      bgMusic.stop();
    }
  }

  function refreshSegments() {
    if (!player) return;
    
    const headZ = -Math.floor(player.position.z / CONFIG.tile);
    
    while (segments.length === 0 || 
           segments[segments.length - 1].z < headZ + CONFIG.segmentsAhead) {
      const nextZ = segments.length ? segments[segments.length - 1].z + 1 : headZ;
      const seg = Math.random() < 0.6 ? addRoadSegment(nextZ) : addSafeSegment(nextZ);
      segments.push(seg);
    }
    
    const minZ = headZ - CONFIG.segmentsBehind;
    while (segments.length && segments[0].z < minZ) {
      const s = segments.shift();
      for (const m of s.meshes) {
        if (m.parent) m.parent.remove(m);
      }
    }
    
    obstacles = obstacles.filter(o => o.parent);
    updateNavigationBounds();
  }
  </script>
</body>
</html>