<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Crossy Road 3D ‚Äì Enhanced (VR)</title>
  <style>
    html, body { 
      margin:0; 
      height:100%; 
      background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1e 100%);
      overflow:hidden; 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    #hud { position: fixed; top: 16px; left: 16px; right: 16px; display:flex; justify-content:space-between; align-items:center; color:#fff; z-index:10; pointer-events:none; text-shadow: 0 3px 6px rgba(0,0,0,.8); }
    .pill{ pointer-events:none; background: linear-gradient(135deg, rgba(59, 130, 246, 0.5) 0%, rgba(37, 99, 235, 0.5) 100%); backdrop-filter: blur(10px); padding: 10px 16px; border-radius: 20px; font-weight: 700; font-size: 16px; border: 1px solid rgba(255,255,255,0.2); box-shadow: 0 4px 15px rgba(0,0,0,0.3); }
    #level-indicator { position: fixed; top: 70px; left: 50%; transform: translateX(-50%); background: linear-gradient(135deg, rgba(168, 85, 247, 0.6) 0%, rgba(139, 92, 246, 0.6) 100%); backdrop-filter: blur(10px); padding: 8px 20px; border-radius: 20px; color: #fff; font-weight: 700; z-index: 10; border: 1px solid rgba(255,255,255,0.3); box-shadow: 0 4px 15px rgba(0,0,0,0.4); }
    #progress { position:fixed; bottom: 16px; left: 16px; right: 16px; height: 10px; background: rgba(0,0,0,0.4); backdrop-filter: blur(5px); border-radius: 10px; border: 1px solid rgba(255,255,255,0.1); overflow: hidden; }
    #bar { height:100%; width:0%; background: linear-gradient(90deg, #4ade80 0%, #22c55e 100%); border-radius: 10px; transition: width .3s ease; box-shadow: 0 0 20px rgba(74, 222, 128, 0.6); }
    #loading-text { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; font-size: 24px; font-weight: 700; z-index: 25; text-align: center; }
    #gameover, #start-screen { position:fixed; inset:0; display:none; place-items:center; background: rgba(0,0,0,.85); backdrop-filter: blur(10px); color:#fff; text-align:center; z-index:20; animation: fadeIn 0.3s ease; }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    #card, #start-card { background: linear-gradient(135deg, #1f2937 0%, #111827 100%); padding: 32px; border-radius: 24px; box-shadow: 0 20px 60px rgba(0,0,0,.7); max-width: 480px; border: 1px solid rgba(255,255,255,0.1); animation: slideUp 0.4s ease; }
    @keyframes slideUp { from { transform: translateY(30px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
    #card h1, #start-card h1 { margin:0 0 12px 0; font-size: 36px; background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
    #card p, #start-card p { opacity:.9; font-size: 18px; margin: 8px 0; }
    #card button, #start-card button { margin-top: 16px; background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%); color: #fff; border: 0; padding: 14px 28px; border-radius: 12px; font-weight: 700; font-size: 16px; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(34, 197, 94, 0.4); }
    #card button:hover, #start-card button:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(34, 197, 94, 0.6); }
    #mobile { position:fixed; bottom: 80px; left:50%; transform:translateX(-50%); display:none; gap: 12px; z-index:15; }
    .btn-container { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; width: 180px; }
    .btn { background: linear-gradient(135deg, rgba(59, 130, 246, 0.4) 0%, rgba(37, 99, 235, 0.4) 100%); backdrop-filter: blur(10px); color: #fff; border: 1px solid rgba(255,255,255,.2); padding: 16px; border-radius: 12px; min-width: 50px; text-align: center; font-weight: 700; font-size: 18px; cursor: pointer; transition: all 0.2s ease; box-shadow: 0 4px 15px rgba(0,0,0,0.3); }
    .btn:active { transform: scale(0.95); background: linear-gradient(135deg, rgba(37, 99, 235, 0.6) 0%, rgba(29, 78, 216, 0.6) 100%); }
    .btn[data-k="KeyW"] { grid-column: 2; } .btn[data-k="KeyA"] { grid-column: 1; grid-row: 2; } .btn[data-k="KeyS"] { grid-column: 2; grid-row: 2; } .btn[data-k="KeyD"] { grid-column: 3; grid-row: 2; }
    .stats { display: flex; justify-content: space-around; margin: 20px 0; gap: 16px; }
    .stat-item { flex: 1; background: rgba(255,255,255,0.05); padding: 12px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); }
    .stat-label { font-size: 14px; opacity: 0.7; margin-bottom: 4px; }
    .stat-value { font-size: 24px; font-weight: 700; color: #4ade80; }
    @media (max-width: 820px){ #mobile { display:block; } #progress { bottom: 160px; } }
    #enter-vr-fallback { position: fixed; right: 16px; bottom: 20px; z-index: 30; background: rgba(255,255,255,0.06); color:#fff; border: 0; padding:10px 14px; border-radius:10px; cursor:pointer; backdrop-filter: blur(6px); display:none; }
  </style>
</head>
<body>
  <!-- Loading Screen -->
  <div id="loading-text">Cargando modelos 3D...<br><span style="font-size:16px;">0%</span></div>
  
  <!-- Start Screen -->
  <div id="start-screen">
    <div id="start-card">
      <h1>üéÆ Crossy Road 3D</h1>
      <p>Cruza la carretera esquivando obst√°culos</p>
      <div style="margin: 20px 0; text-align: left; opacity: 0.8;">
        <p><strong>Controles:</strong></p>
        <p>‚Ä¢ W/‚Üë - Avanzar</p>
        <p>‚Ä¢ A/‚Üê - Izquierda</p>
        <p>‚Ä¢ S/‚Üì - Retroceder</p>
        <p>‚Ä¢ D/‚Üí - Derecha</p>
        <p>En VR: joystick para moverte y bot√≥n "select" para avanzar (mapea al control r√°pido).</p>
      </div>
      <button id="start-btn">¬°Comenzar!</button>
    </div>
  </div>

  <!-- HUD -->
  <div id="hud" style="display:none;">
    <div class="pill">üìç Distancia: <span id="dist">0</span></div>
    <div class="pill">‚ù§Ô∏è Vidas: <span id="lives">3</span></div>
    <div class="pill">‚≠ê Puntos: <span id="score">0</span></div>
  </div>
  
  <div id="level-indicator" style="display:none;">Nivel <span id="level">1</span></div>
  
  <div id="progress"><div id="bar"></div></div>
  
  <!-- Game Over Screen -->
  <div id="gameover">
    <div id="card">
      <h1>¬°Juego Terminado!</h1>
      <div class="stats">
        <div class="stat-item">
          <div class="stat-label">Distancia</div>
          <div class="stat-value" id="finalDist">0</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">Puntos</div>
          <div class="stat-value" id="finalScore">0</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">Nivel</div>
          <div class="stat-value" id="finalLevel">1</div>
        </div>
      </div>
      <button id="retry">üîÑ Reintentar</button>
    </div>
  </div>
  
  <!-- Mobile Controls -->
  <div id="mobile">
    <div class="btn-container">
      <div class="btn" data-k="KeyW">‚Üë</div>
      <div class="btn" data-k="KeyA">‚Üê</div>
      <div class="btn" data-k="KeyS">‚Üì</div>
      <div class="btn" data-k="KeyD">‚Üí</div>
    </div>
  </div>

  <!-- desktop VR fallback button -->
  <button id="enter-vr-fallback">ENTER VR</button>

  <!-- Three and loaders -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/fflate@0.7.4/umd/index.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>

  <script>
  // ============ CONFIGURATION ============
  const CONFIG = {
    tile: 2.0,
    segmentsAhead: 18,
    segmentsBehind: 8,
    lanes: 5,
    laneWidth: 2.0,
    player: { speed: 0.22, radius: 0.8 },
    obstacles: { carSpeedMin: 2.0, carSpeedMax: 4.5, spawnProb: 0.6 },
    lives: 3,
    levelThreshold: 15,
    pointsPerMove: 10,
    pointsPerLevel: 100
  };

  // ============ GAME STATE ============
  let scene, camera, renderer, clock, mixer;
  let player, playerModel, isMoving = false, moveStart = 0;
  let moveFrom = new THREE.Vector3(), moveTo = new THREE.Vector3();
  let distance = 0, lives = CONFIG.lives, score = 0, level = 1;
  let segments = [];
  let obstacles = [];
  let gameStarted = false;
  let difficultyMultiplier = 1.0;
  let animations = {};
  let currentAction = null;

  // VR controller gamepad state
  let controllerGamepad1 = null;
  let controllerGamepad2 = null;
  let lastVRMoveTime = 0;
  const VR_MOVE_COOLDOWN = 200; // ms

  // Loaded models
  let carModels = [];
  let loadedCount = 0;
  const totalModels = 5; // adjust if you change assets

  // UI elements
  const distUI = document.getElementById('dist');
  const livesUI = document.getElementById('lives');
  const scoreUI = document.getElementById('score');
  const levelUI = document.getElementById('level');
  const bar = document.getElementById('bar');
  const gameover = document.getElementById('gameover');
  const startScreen = document.getElementById('start-screen');
  const loadingText = document.getElementById('loading-text');
  const hud = document.getElementById('hud');
  const levelIndicator = document.getElementById('level-indicator');
  const finalDist = document.getElementById('finalDist');
  const finalScore = document.getElementById('finalScore');
  const finalLevel = document.getElementById('finalLevel');
  const retryBtn = document.getElementById('retry');
  const startBtn = document.getElementById('start-btn');
  const enterVrFallback = document.getElementById('enter-vr-fallback');

  // Materials
  let materials = {};

  // ============ VRButton (simple non-module implementation) ============
  const VRButton = {
    createButton: function (renderer) {
      const button = document.createElement('button');
      button.style.position = 'absolute';
      button.style.bottom = '20px';
      button.style.right = '20px';
      button.style.padding = '12px 18px';
      button.style.borderRadius = '999px';
      button.style.border = 'none';
      button.style.fontSize = '14px';
      button.style.fontWeight = '600';
      button.style.cursor = 'pointer';
      button.style.background = '#22c55e';
      button.style.color = '#020617';
      button.style.boxShadow = '0 0 18px rgba(0,0,0,0.45)';
      button.textContent = 'Enter VR';

      function showUnsupported() {
        button.textContent = 'VR no disponible';
        button.disabled = true;
        button.style.background = '#4b5563';
      }

      if ('xr' in navigator) {
        navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
          if (!supported) {
            showUnsupported();
            return;
          }
          let currentSession = null;

          async function onClick() {
            if (currentSession) {
              await currentSession.end();
              return;
            }
            try {
              const session = await navigator.xr.requestSession('immersive-vr', {
                optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking', 'layers', 'layers', 'hit-test']
              });
              currentSession = session;
              renderer.xr.setSession(session);
              button.textContent = 'Exit VR';
              enterVrFallback.style.display = 'none';
              session.addEventListener('end', () => {
                currentSession = null;
                button.textContent = 'Enter VR';
                enterVrFallback.style.display = 'block';
              });
            } catch (e) {
              console.error('No se pudo iniciar la sesi√≥n XR', e);
            }
          }

          button.addEventListener('click', onClick);
        }).catch((err) => {
          console.warn('Error comprobando XR:', err);
          showUnsupported();
        });
      } else {
        showUnsupported();
      }

      return button;
    }
  };

  // ============ INITIALIZATION ============
  init();

  function init() {
    // Scene
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050816);
    scene.fog = new THREE.Fog(0x050816, 20, 70);

    clock = new THREE.Clock();

    // Camera
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);
    camera.position.set(0, 1.6, 0); // default eye height

    // Renderer
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
    renderer.shadowMap.enabled = true;
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    // VR button
    const vrButton = VRButton.createButton(renderer);
    document.body.appendChild(vrButton);
    enterVrFallback.style.display = 'block';
    enterVrFallback.onclick = () => vrButton.click();

    // Lights
    const hemi = new THREE.HemisphereLight(0x555577, 0x050509, 0.8);
    scene.add(hemi);
    const sun = new THREE.DirectionalLight(0xfff1c1, 1.0);
    sun.position.set(10, 20, 5);
    sun.castShadow = true;
    sun.shadow.camera.left = -30;
    sun.shadow.camera.right = 30;
    sun.shadow.camera.top = 30;
    sun.shadow.camera.bottom = -30;
    sun.shadow.mapSize.width = 2048;
    sun.shadow.mapSize.height = 2048;
    scene.add(sun);

    // Textures & materials (using placeholder colors/textures)
    const loaderTex = new THREE.TextureLoader();
    const grassTex = loaderTex.load('TEXTURAS/grass.png', undefined, undefined, () => {});
    grassTex.wrapS = grassTex.wrapT = THREE.RepeatWrapping;
    grassTex.anisotropy = 4;

    materials.grass = new THREE.MeshStandardMaterial({ map: grassTex, roughness: 0.9, metalness: 0.0 });
    materials.road = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.85, metalness: 0.05 });
    materials.roadLine = new THREE.MeshStandardMaterial({ color: 0xfbbf24, emissive: 0xfbbf24, emissiveIntensity: 0.3, roughness: 0.7 });
    materials.rock = new THREE.MeshStandardMaterial({ color: 0x6b7280, roughness: 1.0, metalness: 0 });

    // Ground group
    window.ground = new THREE.Group();
    scene.add(window.ground);

    // Controllers (add early so they exist)
    setupVRControllers();

    // Load HDR and models
    loadHDREnvironment();
    loadModels();

    // Event listeners
    window.addEventListener('resize', onResize);
    window.addEventListener('keydown', onKey);

    // Mobile buttons
    document.querySelectorAll('#mobile .btn').forEach(b => {
      b.addEventListener('click', () => { if (!gameStarted) return; handleMove(b.getAttribute('data-k')); });
    });

    // Start/retry
    startBtn.onclick = startGame;
    retryBtn.onclick = () => location.reload();
  }

  // ============ VR CONTROLLERS SETUP ============
  let controller1 = null;
  let controller2 = null;

  function setupVRControllers() {
    // controllers will be attached when session starts; keep placeholders
    // We'll poll renderer.xr.getController(...) after session begins
    // But create simple pointer meshes to show controllers when present
  }

  function attachControllersIfReady() {
    try {
      controller1 = renderer.xr.getController(0);
      controller2 = renderer.xr.getController(1);

      // Simple controller visuals
      const controllerGeom = new THREE.CylinderGeometry(0.02, 0.02, 0.12, 6);
      const controllerMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x22c55e, emissiveIntensity: 0.2 });
      const mesh1 = new THREE.Mesh(controllerGeom, controllerMat);
      mesh1.rotation.x = Math.PI / 2;
      mesh1.position.z = -0.06;
      controller1.add(mesh1);

      const mesh2 = mesh1.clone();
      controller2.add(mesh2);

      controller1.addEventListener('connected', (e) => {
        if (e.data && e.data.gamepad) controllerGamepad1 = e.data.gamepad;
        controller1.userData.inputSource = e.data;
      });
      controller1.addEventListener('disconnected', () => { controllerGamepad1 = null; delete controller1.userData.inputSource; });

      controller2.addEventListener('connected', (e) => {
        if (e.data && e.data.gamepad) controllerGamepad2 = e.data.gamepad;
        controller2.userData.inputSource = e.data;
      });
      controller2.addEventListener('disconnected', () => { controllerGamepad2 = null; delete controller2.userData.inputSource; });

      controller1.addEventListener('selectstart', () => { // forward
        if (gameStarted) handleMove('KeyW');
      });
      controller2.addEventListener('selectstart', () => { // back
        if (gameStarted) handleMove('KeyS');
      });

      scene.add(controller1);
      scene.add(controller2);
    } catch (e) {
      // ignore until session started
    }
  }

  function processVRInput(dt) {
    if (!renderer.xr.isPresenting || !player) return;
    const now = performance.now();
    if (now - lastVRMoveTime < VR_MOVE_COOLDOWN) return;

    // read axes
    let axisX = 0, axisY = 0;
    const pads = [];
    if (controllerGamepad1 && controllerGamepad1.axes) pads.push(controllerGamepad1);
    if (controllerGamepad2 && controllerGamepad2.axes) pads.push(controllerGamepad2);

    pads.forEach(p => {
      if (!p.axes || p.axes.length < 2) return;
      const x = p.axes[0];
      const y = p.axes[1];
      if (Math.abs(x) > Math.abs(axisX)) axisX = x;
      if (Math.abs(y) > Math.abs(axisY)) axisY = y;
    });

    const threshold = 0.6;
    if (axisY < -threshold) { handleMove('KeyW'); lastVRMoveTime = now; }
    else if (axisY > threshold) { handleMove('KeyS'); lastVRMoveTime = now; }
    else if (axisX < -threshold) { handleMove('KeyA'); lastVRMoveTime = now; }
    else if (axisX > threshold) { handleMove('KeyD'); lastVRMoveTime = now; }
  }

  // ============ HDR & MODELS ============
  function loadHDREnvironment() {
    const rgbeLoader = new THREE.RGBELoader();
    rgbeLoader.load('rgbe/wide_street_4k.hdr',
      (texture) => {
        texture.mapping = THREE.EquirectangularReflectionMapping;
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        pmremGenerator.compileEquirectangularShader();
        const envMap = pmremGenerator.fromEquirectangular(texture).texture;
        scene.environment = envMap;
        pmremGenerator.dispose();
        Object.values(materials).forEach(mat => { if (mat && (mat.isMeshStandardMaterial || mat.isMeshPhysicalMaterial)) { mat.envMap = envMap; mat.needsUpdate = true; }});
        onModelLoaded();
      },
      undefined,
      (err) => {
        console.warn('HDR not found', err);
        onModelLoaded();
      }
    );
  }

  function loadModels() {
    const gltfLoader = new THREE.GLTFLoader();
    const fbxLoader = new THREE.FBXLoader();

    const carConfigs = [
      { path: 'Models/car1.glb', rotation: Math.PI / 2 },
      { path: 'Models/car2.glb', rotation: 0 },
      { path: 'Models/coupe_car.glb', rotation: 0 }
    ];

    carConfigs.forEach((cfg, idx) => {
      gltfLoader.load(cfg.path,
        (gltf) => {
          const model = gltf.scene;
          // normalize size
          const box = new THREE.Box3().setFromObject(model);
          const size = box.getSize(new THREE.Vector3());
          const maxDim = Math.max(size.x, size.y, size.z);
          const targetSize = 2.0;
          const normalizeScale = (maxDim > 0) ? targetSize / maxDim : 1;
          model.scale.set(normalizeScale, normalizeScale, normalizeScale);
          if (cfg.rotation) model.rotation.y = cfg.rotation;
          const wrapper = new THREE.Group();
          wrapper.add(model);
          wrapper.traverse(child => { if (child.isMesh) { child.castShadow = true; child.receiveShadow = true; }});
          carModels.push(wrapper);
          onModelLoaded();
        },
        (progress) => {
          if (progress.total) updateLoadingProgress(idx, (progress.loaded / progress.total) / carConfigs.length);
        },
        (err) => {
          console.error('Error loading car', cfg.path, err);
          carModels.push(createFallbackCar());
          onModelLoaded();
        }
      );
    });

    // player model (FBX)
    fbxLoader.load('Models/Taunt.fbx',
      (fbx) => {
        playerModel = fbx;
        playerModel.scale.set(0.01, 0.01, 0.01);
        playerModel.position.set(0, 0, 0);
        playerModel.traverse(child => { if (child.isMesh) { child.castShadow = true; child.receiveShadow = true; }});
        mixer = new THREE.AnimationMixer(playerModel);
        if (fbx.animations && fbx.animations.length) {
          animations.idle = mixer.clipAction(fbx.animations[0]);
          animations.idle.setLoop(THREE.LoopRepeat);
        }
        // try load additional anims
        fbxLoader.load('Models/reposo.fbx', (anim) => {
          if (anim.animations && anim.animations.length) {
            animations.idle = mixer.clipAction(anim.animations[0]);
            animations.idle.setLoop(THREE.LoopRepeat);
          }
          loadRunAnimation(fbxLoader);
        }, undefined, () => { loadRunAnimation(fbxLoader); });
      },
      (progress) => { if (progress.total) updateLoadingProgress(3, (progress.loaded / progress.total) / totalModels); },
      (err) => {
        console.error('Error loading player', err);
        const geo = new THREE.BoxGeometry(1,1.5,0.8);
        const mat = new THREE.MeshStandardMaterial({ color: 0x22c55e });
        playerModel = new THREE.Mesh(geo, mat);
        playerModel.castShadow = true;
        mixer = new THREE.AnimationMixer(playerModel);
        onModelLoaded();
      }
    );

    // optional props (not required)
    fbxLoader.load('Models/muerte.fbx', (res) => { /* ignore */ }, undefined, () => {});
    fbxLoader.load('Models/wood box.fbx', (res) => { /* ignore */ }, undefined, () => {});
  }

  function loadRunAnimation(fbxLoader) {
    fbxLoader.load('Models/correr.fbx', (anim) => {
      if (anim.animations && anim.animations.length) {
        animations.run = mixer.clipAction(anim.animations[0]);
        animations.run.setLoop(THREE.LoopRepeat);
      }
      loadDeathAnimation(fbxLoader);
    }, undefined, () => { loadDeathAnimation(fbxLoader); });
  }

  function loadDeathAnimation(fbxLoader) {
    fbxLoader.load('Models/muerte.fbx', (anim) => {
      if (anim.animations && anim.animations.length) {
        animations.death = mixer.clipAction(anim.animations[0]);
        animations.death.setLoop(THREE.LoopOnce);
        animations.death.clampWhenFinished = true;
      }
      onModelLoaded();
    }, undefined, () => { onModelLoaded(); });
  }

  function createFallbackCar() {
    const group = new THREE.Group();
    const bodyGeo = new THREE.BoxGeometry(1.4, 0.9, 2.2);
    const bodyMat = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff, roughness: 0.3, metalness: 0.7 });
    const body = new THREE.Mesh(bodyGeo, bodyMat); body.position.y = 0.45; body.castShadow = true; group.add(body);
    const roofGeo = new THREE.BoxGeometry(1.2, 0.6, 1.2);
    const roof = new THREE.Mesh(roofGeo, bodyMat); roof.position.set(0,0.9,-0.2); roof.castShadow=true; group.add(roof);
    return group;
  }

  function onModelLoaded() {
    loadedCount++;
    const progress = loadedCount / totalModels;
    updateLoadingProgress(loadedCount - 1, progress);
    if (loadedCount >= totalModels) {
      finishLoading();
    }
  }

  function updateLoadingProgress(index, ratio) {
    const percent = Math.round(ratio * 100);
    loadingText.querySelector('span').textContent = `${percent}%`;
    bar.style.width = percent + '%';
  }

  function finishLoading() {
    loadingText.style.display = 'none';
    if (playerModel) {
      player = new THREE.Group();
      player.add(playerModel);
      player.position.set(0, 0, 0);
      scene.add(player);
      if (animations.idle) { currentAction = animations.idle; currentAction.play(); }
    }
    startScreen.style.display = 'grid';
    setTimeout(() => { document.getElementById('progress').style.display = 'none'; }, 300);
  }

  // ============ GAME START & SEGMENTS ============
  function startGame() {
    startScreen.style.display = 'none';
    hud.style.display = 'flex';
    levelIndicator.style.display = 'block';
    gameStarted = true;

    // attach controllers if session already active
    attachControllersIfReady();

    for (let i = -CONFIG.segmentsBehind; i <= CONFIG.segmentsAhead; i++) {
      const seg = (i <= 2) ? addSafeSegment(i) : (Math.random() < 0.6 ? addRoadSegment(i) : addSafeSegment(i));
      segments.push(seg);
    }

    // ensure VR loop
    renderer.setAnimationLoop(gameLoop);
  }

  function addSafeSegment(zIndex) {
    const tileW = CONFIG.lanes * CONFIG.laneWidth + 4.0;
    const plane = new THREE.Mesh(new THREE.BoxGeometry(tileW, 0.3, CONFIG.tile), materials.grass);
    plane.position.set(0, -0.15, -zIndex * CONFIG.tile);
    plane.receiveShadow = true;
    window.ground.add(plane);
    const created = [plane];
    if (Math.random() < 0.3) {
      for (let i=0;i<2;i++){
        const r = new THREE.Mesh(new THREE.DodecahedronGeometry(0.4 + Math.random()*0.3), materials.rock);
        const lane = (Math.random()-0.5) * (CONFIG.lanes-1) * CONFIG.laneWidth;
        r.position.set(lane, 0.4, -zIndex*CONFIG.tile + (Math.random()-0.5));
        r.castShadow = true;
        r.userData = { type: 'rock', isObstacle: true };
        obstacles.push(r);
        window.ground.add(r);
        created.push(r);
      }
    }
    return { z: zIndex, type: 'safe', meshes: created };
  }

  function addRoadSegment(zIndex) {
    const tileW = CONFIG.lanes * CONFIG.laneWidth + 4.0;
    const plane = new THREE.Mesh(new THREE.BoxGeometry(tileW, 0.3, CONFIG.tile), materials.road);
    plane.position.set(0, -0.15, -zIndex * CONFIG.tile);
    plane.receiveShadow = true;
    window.ground.add(plane);
    const created = [plane];
    const lineGeo = new THREE.BoxGeometry(0.15, 0.05, CONFIG.tile * 0.4);
    for (let lane = -Math.floor(CONFIG.lanes/2); lane < Math.floor(CONFIG.lanes/2); lane++) {
      const line = new THREE.Mesh(lineGeo, materials.roadLine);
      line.position.set((lane+0.5)*CONFIG.laneWidth, 0.05, -zIndex*CONFIG.tile);
      window.ground.add(line); created.push(line);
    }
    const direction = Math.random() < 0.5 ? 1 : -1;
    const lanesArray = [];
    for (let lane = -Math.floor(CONFIG.lanes/2); lane <= Math.floor(CONFIG.lanes/2); lane++) lanesArray.push(lane);
    lanesArray.sort(() => Math.random() - 0.5);
    for (const lane of lanesArray) {
      if (Math.random() < CONFIG.obstacles.spawnProb * difficultyMultiplier && carModels.length > 0) {
        const carIndex = Math.floor(Math.random()*carModels.length);
        const carClone = carModels[carIndex].clone();
        carClone.position.set(lane * CONFIG.laneWidth, 0, -zIndex * CONFIG.tile);
        if (direction < 0) carClone.rotation.y += Math.PI;
        carClone.userData = { type: 'car', speed: THREE.MathUtils.lerp(CONFIG.obstacles.carSpeedMin, CONFIG.obstacles.carSpeedMax, Math.random()) * difficultyMultiplier, dir: direction };
        obstacles.push(carClone);
        window.ground.add(carClone);
        created.push(carClone);
        break;
      }
    }
    return { z: zIndex, type: 'road', meshes: created };
  }

  // ============ INPUT HANDLING ============
  function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function onKey(e) {
    if (!gameStarted) {
      if (e.code === 'Enter' || e.code === 'Space') {
        if (startScreen.style.display !== 'none') startGame();
      }
      return;
    }
    handleMove(e.code);
  }

  function handleMove(code) {
    if (isMoving || !gameStarted || !player) return;
    const step = CONFIG.tile;
    let nx = player.position.x;
    let nz = player.position.z;
    let moved = false;
    if (code === 'KeyW' || code === 'ArrowUp') { nz -= step; moved = true; }
    else if (code === 'KeyS' || code === 'ArrowDown') { nz += step; moved = true; }
    else if (code === 'KeyA' || code === 'ArrowLeft') { nx -= CONFIG.laneWidth; moved = true; }
    else if (code === 'KeyD' || code === 'ArrowRight') { nx += CONFIG.laneWidth; moved = true; }
    if (!moved) return;
    const maxLane = Math.floor(CONFIG.lanes/2) * CONFIG.laneWidth;
    nx = Math.max(-maxLane, Math.min(maxLane, nx));
    isMoving = true;
    moveStart = performance.now();
    moveFrom.copy(player.position);
    moveTo.set(nx, 0, nz);

    if (animations.run) {
      if (currentAction !== animations.run) {
        if (currentAction) currentAction.fadeOut(0.2);
        currentAction = animations.run;
        currentAction.reset().fadeIn(0.2).play();
      }
    }

    const dir = new THREE.Vector3().subVectors(moveTo, moveFrom);
    if (dir.lengthSq() > 0) {
      const targetRot = Math.atan2(dir.x, dir.z);
      const startRot = player.rotation.y || 0;
      const rotDiff = ((targetRot - startRot + Math.PI * 3) % (Math.PI * 2)) - Math.PI;
      player.userData.rotAnim = { start: startRot, diff: rotDiff };
    }
  }

  // ============ GAME LOOP ============
  function gameLoop() {
    const dt = clock.getDelta();

    if (mixer) mixer.update(dt);

    // VR input
    processVRInput(dt);

    if (isMoving && player) {
      const elapsed = performance.now() - moveStart;
      const duration = CONFIG.player.speed * 1000;
      const t = Math.min(1, elapsed / duration);
      const ease = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;

      player.position.lerpVectors(moveFrom, moveTo, ease);
      player.position.y = Math.sin(t * Math.PI) * 0.2;

      if (player.userData.rotAnim) {
        const { start, diff } = player.userData.rotAnim;
        player.rotation.y = start + diff * ease;
      }

      if (t >= 1) {
        isMoving = false;
        player.position.y = 0;
        if (animations.idle) {
          if (currentAction !== animations.idle) {
            if (currentAction) currentAction.fadeOut(0.3);
            currentAction = animations.idle;
            currentAction.reset().fadeIn(0.3).play();
          }
        }
        if (moveTo.z < moveFrom.z) {
          distance += 1;
          score += CONFIG.pointsPerMove;
          distUI.textContent = distance;
          scoreUI.textContent = score;
          if (distance > 0 && distance % CONFIG.levelThreshold === 0) levelUp();
        }
        refreshSegments();
      }
    }

    // Move car obstacles
    for (const o of obstacles) {
      if (!o.userData || o.userData.type !== 'car') continue;
      const dir = o.userData.dir || 1;
      const speed = o.userData.speed || 2.0;
      o.position.x += dir * speed * dt;
      const maxX = (CONFIG.lanes / 2) * CONFIG.laneWidth + 5;
      if (o.position.x > maxX) o.position.x = -maxX;
      if (o.position.x < -maxX) o.position.x = maxX;
    }

    checkCollisions();

    // Camera follow when not presenting or keep camera in player while presenting
    if (player) {
      if (!renderer.xr.isPresenting) {
        // third-person overhead when not in VR
        const targetCam = new THREE.Vector3(player.position.x * 0.3, 12, player.position.z + 16);
        camera.position.lerp(targetCam, 0.1);
        camera.lookAt(new THREE.Vector3(player.position.x * 0.2, 0, player.position.z - 3));
      } else {
        // In VR the camera is parented to player; ensure camera position is eye height
        camera.position.set(0, 1.6, 0);
      }
    }

    renderer.render(scene, camera);
  }

  // ============ COLLISIONS & GAME EVENTS ============
  function checkCollisions() {
    if (!player || player.userData.invincible) return;
    const playerBox = new THREE.Box3().setFromObject(player);
    for (const o of obstacles) {
      if (!o.parent || !o.userData) continue;
      if (o.userData.type === 'car' || o.userData.isObstacle) {
        const obstacleBox = new THREE.Box3().setFromObject(o);
        if (playerBox.intersectsBox(obstacleBox)) {
          onHit();
          break;
        }
      }
    }
  }

  function onHit() {
    if (player.userData.hitCooldown && performance.now() - player.userData.hitCooldown < 1500) return;
    player.userData.hitCooldown = performance.now();
    player.userData.invincible = true;
    lives--;
    livesUI.textContent = lives;

    if (animations.death && mixer) {
      if (currentAction) currentAction.fadeOut(0.1);
      currentAction = animations.death;
      currentAction.reset();
      currentAction.setLoop(THREE.LoopOnce);
      currentAction.clampWhenFinished = true;
      currentAction.fadeIn(0.1).play();
      setTimeout(() => {
        if (lives > 0 && animations.idle) {
          if (currentAction) currentAction.fadeOut(0.3);
          currentAction = animations.idle;
          currentAction.reset().fadeIn(0.3).play();
        }
      }, 1000);
    }

    if (playerModel) {
      playerModel.traverse(child => {
        if (child.isMesh && child.material) {
          const originalMat = child.material;
          child.userData.originalMaterial = originalMat.clone();
          child.material = child.material.clone();
          child.material.color.setHex(0xff0000);
          child.material.emissive.setHex(0xff0000);
          setTimeout(() => { if (child.userData.originalMaterial) child.material = child.userData.originalMaterial; }, 300);
        }
      });
    }

    if (lives <= 0) {
      setTimeout(() => endGame(), 1500);
    } else {
      setTimeout(() => {
        player.position.set(0, 0, player.position.z + CONFIG.tile * 2);
        moveFrom.copy(player.position);
        moveTo.copy(player.position);
        player.userData.invincible = false;
      }, 1000);
    }
  }

  function levelUp() {
    level++;
    score += CONFIG.pointsPerLevel;
    levelUI.textContent = level;
    scoreUI.textContent = score;
    difficultyMultiplier = 1 + (level - 1) * 0.15;
    levelIndicator.style.transform = 'translateX(-50%) scale(1.3)';
    levelIndicator.style.background = 'linear-gradient(135deg, rgba(251, 191, 36, 0.8) 0%, rgba(245, 158, 11, 0.8) 100%)';
    setTimeout(() => {
      levelIndicator.style.transform = 'translateX(-50%) scale(1)';
      levelIndicator.style.background = 'linear-gradient(135deg, rgba(168, 85, 247, 0.6) 0%, rgba(139, 92, 246, 0.6) 100%)';
    }, 500);
  }

  function endGame() {
    gameStarted = false;
    gameover.style.display = 'grid';
    finalDist.textContent = distance;
    finalScore.textContent = score;
    finalLevel.textContent = level;
    // stop VR loop
    renderer.setAnimationLoop(null);
  }

  function refreshSegments() {
    if (!player) return;
    const headZ = -Math.floor(player.position.z / CONFIG.tile);

    while (segments.length === 0 || segments[segments.length - 1].z < headZ + CONFIG.segmentsAhead) {
      const nextZ = segments.length ? segments[segments.length - 1].z + 1 : headZ;
      const seg = Math.random() < 0.6 ? addRoadSegment(nextZ) : addSafeSegment(nextZ);
      segments.push(seg);
    }

    const minZ = headZ - CONFIG.segmentsBehind;
    while (segments.length && segments[0].z < minZ) {
      const s = segments.shift();
      for (const m of s.meshes) {
        if (m.parent) m.parent.remove(m);
        if (m.geometry) m.geometry.dispose();
        if (m.material) {
          if (Array.isArray(m.material)) m.material.forEach(mat => { if (mat.dispose) mat.dispose(); });
          else if (m.material.dispose) m.material.dispose();
        }
      }
    }
    obstacles = obstacles.filter(o => o.parent);
  }

  // Poll for VR session start to attach camera to player & controllers
  // We listen to renderer.xr for session start/end
  renderer && (function listenXR() {
    try {
      renderer.xr.addEventListener('sessionstart', () => {
        // ensure controllers attached
        attachControllersIfReady();

        // parent camera to player for first-person
        if (player && camera) {
          player.add(camera);
          camera.position.set(0, 1.6, 0);
        }

        // hide player model meshes in VR
        if (player) {
          player.traverse(obj => {
            if (obj.isMesh) {
              if (obj.userData._origVis === undefined) obj.userData._origVis = obj.visible;
              obj.visible = false;
            }
          });
        }

        // start loop (ensure setAnimationLoop active)
        renderer.setAnimationLoop(gameLoop);
      });

      renderer.xr.addEventListener('sessionend', () => {
        // restore camera to scene root
        try {
          if (camera.parent && camera.parent.remove) camera.parent.remove(camera);
          scene.add(camera);
          camera.position.set(0, 12, 16);
        } catch (e) {}

        // restore player model visibility
        if (player) {
          player.traverse(obj => {
            if (obj.isMesh && obj.userData._origVis !== undefined) obj.visible = obj.userData._origVis;
          });
        }

        // stop VR animation loop
        renderer.setAnimationLoop(gameLoop);
      });
    } catch (e) {
      // ignore if no xr support yet
    }
  })();

  // Ensure animate runs when not in VR (fallback)
  // Use requestAnimationFrame loop that calls gameLoop-render for non-VR usage
  (function nonVrLoop(){
    let running = true;
    function tick() {
      if (!running) return;
      if (!renderer.xr.isPresenting) gameLoop();
      requestAnimationFrame(tick);
    }
    tick();
  })();

  // Expose handleMove globally so module-less controller code can call it
  window.handleMove = handleMove;

  // final note: attach controllers if already available
  setTimeout(() => attachControllersIfReady(), 1000);

  </script>
</body>
</html>